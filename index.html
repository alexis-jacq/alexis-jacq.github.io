<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Paper Tracker</title>
    <style>
        :root { --primary: #2563eb; --success: #16a34a; --bg: #f8fafc; --text: #1e293b; --danger: #ef4444; }
        body { font-family: -apple-system, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: var(--bg); color: var(--text); }
        .container { display: grid; grid-template-columns: 300px 1fr; gap: 20px; }
        
        /* Sidebar */
        .sidebar { background: white; padding: 15px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); height: 85vh; display: flex; flex-direction: column; }
        .tree-container { flex-grow: 1; overflow-y: auto; margin-bottom: 15px; }
        .backup-section { border-top: 1px solid #eee; padding-top: 15px; }
        
        /* Tree Visualization (Updated for Collapsing) */
        .tree-item { margin-top: 5px; }
        
        .folder { font-weight: bold; cursor: pointer; color: #475569; font-size: 0.95em; user-select: none; display: flex; align-items: center; gap: 5px;}
        .folder:hover { color: var(--primary); }
        
        /* Dynamic Arrows for Folders */
        .folder::before { content: "‚ñ∂"; font-size: 0.7em; display: inline-block; width: 15px; transition: transform 0.2s; }
        .folder.open::before { content: "‚ñº"; transform: rotate(0deg); }
        .folder-icon { margin-right: 5px; }

        /* The Container that hides/shows children */
        .children-container { 
            display: none; 
            margin-left: 9px; /* Align with arrow */
            padding-left: 15px; 
            border-left: 1px solid #e2e8f0;
        }
        .children-container.expanded { display: block; }
        
        /* Paper Links */
        .file { cursor: pointer; font-size: 0.9em; margin-top: 6px; display: block; text-decoration: none; padding: 2px 0; margin-left: 5px;}
        .file:hover { text-decoration: underline; }
        
        /* Status Colors */
        .status-unread { color: var(--primary); }
        .status-unread::before { content: "üìñ "; }
        .status-read { color: var(--success); opacity: 0.8; }
        .status-read::before { content: "‚úÖ "; }

        /* Main Content */
        .main { background: white; padding: 25px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); position: relative; }
        input[type="text"], textarea, select { width: 100%; margin-bottom: 10px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;}
        
        .checkbox-wrapper { display: flex; align-items: center; gap: 10px; margin-bottom: 20px; background: #f0f9ff; padding: 10px; border-radius: 4px; border: 1px solid #bae6fd; }
        input[type="checkbox"] { transform: scale(1.5); cursor: pointer; }
        
        .btn-group { display: flex; gap: 10px; margin-bottom: 20px; }
        button { background: var(--primary); color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; }
        button.secondary { background: #64748b; }
        button.danger { background: var(--danger); }
        button:hover { opacity: 0.9; }
        
        #api-section { margin-bottom: 20px; padding: 15px; background: #e0f2fe; border-radius: 4px; border: 1px solid #bae6fd; display: none; }
        .status-ok { color: green; font-weight: bold; }
        .status-err { color: red; font-weight: bold; }
        
        #fileInput { display: none; }
    </style>
</head>
<body>

    <div style="display: flex; justify-content: space-between; align-items: center;">
        <h1>üìö Scientific Paper Tracker</h1>
        <button class="secondary" onclick="toggleApiSettings()">‚öôÔ∏è AI Settings</button>
    </div>
    
    <div id="api-section">
        <h3>AI Configuration</h3>
        <label>1. API Key (Stored in browser)</label>
        <input type="password" id="apiKey" placeholder="Paste 'AIza...' key here" onchange="saveSettings()">
        
        <label>2. Select Model</label>
        <div style="display:flex; gap:10px;">
            <select id="modelSelect" onchange="saveSettings()">
                <option value="gemini-1.5-flash">Default (gemini-1.5-flash)</option>
            </select>
            <button class="secondary" onclick="fetchModels()">üîÑ Refresh Models</button>
        </div>
        <p id="connectionStatus" style="font-size: 0.9em; margin-top: 10px;"></p>
    </div>

    <div class="container">
        <div class="sidebar">
            <h3>Library</h3>
            <div id="tree-root" class="tree-container"></div>
            
            <div class="backup-section">
                <small style="color:#666; display:block; margin-bottom:5px;">Data Backup</small>
                <button class="secondary" style="width:100%; margin-bottom:5px;" onclick="downloadJson()">‚¨áÔ∏è Save Backup (JSON)</button>
                <button class="secondary" style="width:100%;" onclick="triggerRestore()">‚¨ÜÔ∏è Load Backup (JSON)</button>
                <input type="file" id="fileInput" accept=".json" onchange="loadJson(this)">
            </div>
        </div>

        <div class="main">
            <h3>Add New Paper</h3>
            <div class="btn-group">
                <input type="text" id="inputUrl" placeholder="Paste Paper Abstract text here...">
                <button onclick="autoFillWithAI()">‚ú® Magic Fill</button>
            </div>

            <label>Title</label>
            <input type="text" id="title">
            
            <label>Hierarchy (Path)</label>
            <input type="text" id="path" placeholder="e.g. diffusion/post-training">
            
            <div class="checkbox-wrapper">
                <input type="checkbox" id="readStatus">
                <label for="readStatus" style="font-weight:bold; color:#1e293b;">Mark as Read / Finished</label>
            </div>
            
            <label>One-Sentence Summary</label>
            <textarea id="summary" rows="2"></textarea>

            <label>BibTeX</label>
            <textarea id="bibtex" rows="5" style="font-family: monospace;"></textarea>

            <div class="btn-group">
                <button onclick="savePaper()">üíæ Save Paper</button>
                <button class="secondary" onclick="clearForm()">Clear</button>
                <button class="danger" onclick="deleteCurrentPaper()">üóëÔ∏è Delete</button>
                <button class="secondary" onclick="exportBib()">‚¨áÔ∏è Export .bib</button>
            </div>
        </div>
    </div>

    <script>
        // --- DATA LAYER ---
        let papers = JSON.parse(localStorage.getItem('myPapers')) || [];
        let expandedPaths = new Set(); // State to track open folders
        
        // --- API SETTINGS LAYER ---
        function getApiKey() { return localStorage.getItem('geminiKey') || ''; }
        function getModel() { return localStorage.getItem('geminiModel') || 'gemini-1.5-flash'; }

        document.addEventListener('DOMContentLoaded', () => {
            const key = getApiKey();
            if(key) document.getElementById('apiKey').value = key;
            
            const savedModel = getModel();
            const select = document.getElementById('modelSelect');
            if(savedModel && select.options.length === 1) {
                const opt = document.createElement('option');
                opt.value = savedModel;
                opt.text = `Saved: ${savedModel}`;
                opt.selected = true;
                select.add(opt);
            }
            renderTree();
        });

        function saveSettings() {
            localStorage.setItem('geminiKey', document.getElementById('apiKey').value);
            localStorage.setItem('geminiModel', document.getElementById('modelSelect').value);
        }

        function toggleApiSettings() {
            const el = document.getElementById('api-section');
            el.style.display = el.style.display === 'none' ? 'block' : 'none';
        }

        function logStatus(msg, type='neutral') {
            const statusEl = document.getElementById('connectionStatus');
            const color = type === 'error' ? 'red' : (type === 'success' ? 'green' : '#666');
            statusEl.innerHTML = `<span style="color:${color}; font-weight:bold">${msg}</span>`;
        }

        // --- BACKUP & RESTORE ---
        function downloadJson() {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(papers, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "my_papers_backup.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        function triggerRestore() { document.getElementById('fileInput').click(); }

        function loadJson(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const loadedPapers = JSON.parse(e.target.result);
                    if (Array.isArray(loadedPapers)) {
                        if(confirm(`Found ${loadedPapers.length} papers. Replace library?`)) {
                            papers = loadedPapers;
                            localStorage.setItem('myPapers', JSON.stringify(papers));
                            renderTree();
                            alert("Restored!");
                        }
                    } else alert("Invalid JSON.");
                } catch (err) { alert("Error: " + err.message); }
                input.value = ''; 
            };
            reader.readAsText(file);
        }

        // --- MODEL FETCHER ---
        async function fetchModels() {
            const key = document.getElementById('apiKey').value;
            if(!key) return alert("Please enter an API Key first.");
            logStatus("Connecting...", "neutral");
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${key}`);
                const data = await response.json();
                if(data.error) throw new Error(data.error.message);
                const select = document.getElementById('modelSelect');
                select.innerHTML = '';
                const validModels = data.models.filter(m => m.supportedGenerationMethods?.includes("generateContent"));
                validModels.forEach(m => {
                    const cleanName = m.name.replace('models/', '');
                    const option = document.createElement('option');
                    option.value = cleanName;
                    option.text = `${m.displayName} (${cleanName})`;
                    if(cleanName.includes('1.5-flash')) option.selected = true;
                    select.appendChild(option);
                });
                logStatus(`‚úÖ Found ${validModels.length} models.`, "success");
                saveSettings(); 
            } catch (e) { logStatus(`‚ùå Error: ${e.message}`, "error"); }
        }

        // --- AI LOGIC ---
        async function autoFillWithAI() {
            const apiKey = getApiKey();
            const model = getModel();
            const input = document.getElementById('inputUrl').value;
            if (!apiKey) { toggleApiSettings(); return alert("Please configure API Key."); }
            if (!input) return alert("Please enter text.");

            const button = document.querySelector('button[onclick="autoFillWithAI()"]');
            const originalText = button.textContent;
            button.textContent = "‚è≥ Generating...";
            button.disabled = true;
            logStatus(`Requesting ${model}...`, "neutral");

            const prompt = `
            You are a Citation Manager. Input: "${input}"
            Tasks: 1. Title 2. Path (field/subfield) 3. One sentence summary 4. BibTeX citation (use Unknown if missing data).
            Return JSON keys: title, path, summary, bibtex. No markdown.
            `;
            
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000);

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }),
                    signal: controller.signal
                });
                clearTimeout(timeoutId); 
                const data = await response.json();
                if (data.error) throw new Error(data.error.message);
                
                let text = data.candidates?.[0]?.content?.parts?.[0]?.text || "";
                text = text.replace(/```json/g, '').replace(/```/g, '').trim(); 
                const result = JSON.parse(text);
                
                document.getElementById('title').value = result.title || "";
                document.getElementById('path').value = (result.path || "").toLowerCase().replace(/ /g, '_');
                document.getElementById('summary').value = result.summary || "";
                document.getElementById('bibtex').value = result.bibtex || "@misc{unknown, title={Unknown}, author={Unknown}, year={2024}}";
                document.getElementById('readStatus').checked = false;

                logStatus("‚úÖ Done!", "success");
            } catch (e) {
                logStatus(e.name === 'AbortError' ? "‚ùå Timeout." : `‚ùå Error: ${e.message}`, "error");
                if(e.name !== 'AbortError') alert(e.message);
            } finally {
                button.textContent = originalText;
                button.disabled = false;
            }
        }

        // --- APP LOGIC ---
        function savePaper() {
            const title = document.getElementById('title').value;
            if (!title) return alert("Title is required!");

            const newPaper = {
                id: Date.now(),
                title: title,
                path: document.getElementById('path').value || 'Uncategorized',
                summary: document.getElementById('summary').value,
                bibtex: document.getElementById('bibtex').value,
                url: document.getElementById('inputUrl').value,
                read: document.getElementById('readStatus').checked
            };

            const existingIndex = papers.findIndex(p => p.title === title);
            if (existingIndex > -1) {
                newPaper.id = papers[existingIndex].id;
                papers.splice(existingIndex, 1);
            }
            
            papers.push(newPaper);
            localStorage.setItem('myPapers', JSON.stringify(papers));
            renderTree();
            clearForm();
        }

        function loadPaper(id) {
            const paper = papers.find(p => p.id === id);
            if (!paper) return;
            document.getElementById('title').value = paper.title;
            document.getElementById('path').value = paper.path;
            document.getElementById('summary').value = paper.summary;
            document.getElementById('bibtex').value = paper.bibtex;
            document.getElementById('inputUrl').value = paper.url;
            document.getElementById('readStatus').checked = paper.read || false;
        }

        function deleteCurrentPaper() {
            const title = document.getElementById('title').value;
            if (!title) return;
            const existingIndex = papers.findIndex(p => p.title === title);
            if (existingIndex > -1 && confirm("Delete '" + title + "'?")) {
                papers.splice(existingIndex, 1);
                localStorage.setItem('myPapers', JSON.stringify(papers));
                renderTree();
                clearForm();
            }
        }

        function clearForm() {
            document.getElementById('title').value = '';
            document.getElementById('path').value = '';
            document.getElementById('summary').value = '';
            document.getElementById('bibtex').value = '';
            document.getElementById('inputUrl').value = '';
            document.getElementById('readStatus').checked = false;
        }
        
        function exportBib() {
            const bibContent = papers.map(p => p.bibtex).join('\n\n');
            const blob = new Blob([bibContent], { type: 'text/plain' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'library.bib';
            a.click();
        }

        // --- NEW COLLAPSIBLE TREE LOGIC ---
        function renderTree() {
            const root = document.getElementById('tree-root');
            root.innerHTML = '';
            const tree = {};
            
            // Build Structure
            papers.forEach(p => {
                const parts = p.path.split('/').map(s => s.trim()).filter(s => s);
                let current = tree;
                parts.forEach((part, i) => {
                    if (!current[part]) current[part] = { _files: [], _folders: {} };
                    if (i === parts.length - 1) current[part]._files.push(p);
                    current = current[part]._folders;
                });
            });

            // Recursive Renderer with "fullPath" to track state
            function createNode(name, data, parentElement, fullPath) {
                const itemContainer = document.createElement('div');
                itemContainer.className = 'tree-item';

                // 1. Render FOLDER Label
                if (name) {
                    const folderDiv = document.createElement('div');
                    folderDiv.className = 'folder';
                    
                    // Folder Icon
                    const icon = document.createElement('span');
                    icon.className = 'folder-icon';
                    icon.textContent = 'üìÇ';
                    
                    folderDiv.appendChild(icon);
                    folderDiv.appendChild(document.createTextNode(name));

                    // Toggle Logic
                    const isOpen = expandedPaths.has(fullPath);
                    if(isOpen) folderDiv.classList.add('open');
                    
                    folderDiv.onclick = (e) => {
                        const childrenEl = itemContainer.querySelector('.children-container');
                        if(childrenEl) {
                            // Toggle State
                            if(childrenEl.classList.contains('expanded')) {
                                childrenEl.classList.remove('expanded');
                                folderDiv.classList.remove('open');
                                expandedPaths.delete(fullPath);
                            } else {
                                childrenEl.classList.add('expanded');
                                folderDiv.classList.add('open');
                                expandedPaths.add(fullPath);
                            }
                        }
                    };
                    itemContainer.appendChild(folderDiv);
                }

                // 2. Render CHILDREN Wrapper (Files + Subfolders)
                // If it's the root level, always show, otherwise use display logic
                const childrenContainer = document.createElement('div');
                childrenContainer.className = 'children-container';
                if(expandedPaths.has(fullPath) || !name) {
                    childrenContainer.classList.add('expanded');
                }

                // Add Files
                if (data._files) {
                    data._files.forEach(f => {
                        const fileEl = document.createElement('span');
                        const isRead = f.read === true;
                        fileEl.className = 'file ' + (isRead ? 'status-read' : 'status-unread');
                        fileEl.textContent = f.title;
                        fileEl.onclick = () => loadPaper(f.id);
                        childrenContainer.appendChild(fileEl);
                    });
                }

                // Add Subfolders (Recursive)
                if (data._folders) {
                    Object.keys(data._folders).forEach(key => {
                        const nextPath = fullPath ? `${fullPath}/${key}` : key;
                        createNode(key, { 
                            _files: [], 
                            _folders: data._folders[key]._folders, 
                            ...data._folders[key] 
                        }, childrenContainer, nextPath);
                    });
                }
                
                // Only append children container if not empty
                if (childrenContainer.hasChildNodes()) {
                    itemContainer.appendChild(childrenContainer);
                }

                parentElement.appendChild(itemContainer);
            }

            // Start recursion
            Object.keys(tree).forEach(k => createNode(k, tree[k], root, k));
        }
    </script>
</body>
</html>
