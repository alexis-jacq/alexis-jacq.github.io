<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Paper Tracker</title>
    <style>
        :root { --primary: #2563eb; --bg: #f8fafc; --text: #1e293b; --danger: #ef4444; }
        body { font-family: -apple-system, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: var(--bg); color: var(--text); }
        .container { display: grid; grid-template-columns: 300px 1fr; gap: 20px; }
        
        /* Sidebar */
        .sidebar { background: white; padding: 15px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); height: 85vh; display: flex; flex-direction: column; }
        .tree-container { flex-grow: 1; overflow-y: auto; margin-bottom: 15px; }
        .backup-section { border-top: 1px solid #eee; padding-top: 15px; }
        
        .tree-item { margin-left: 15px; border-left: 1px solid #ddd; padding-left: 10px; margin-top: 5px; }
        .folder { font-weight: bold; cursor: pointer; color: #475569; }
        .folder::before { content: "üìÅ "; }
        .file { cursor: pointer; color: var(--primary); font-size: 0.9em; margin-top: 4px; display: block; }
        .file:hover { text-decoration: underline; }

        /* Main Content */
        .main { background: white; padding: 25px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        input, textarea, select { width: 100%; margin-bottom: 10px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;}
        .btn-group { display: flex; gap: 10px; margin-bottom: 20px; }
        button { background: var(--primary); color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; }
        button.secondary { background: #64748b; }
        button.danger { background: var(--danger); }
        button:hover { opacity: 0.9; }
        
        /* API Config Box */
        #api-section { margin-bottom: 20px; padding: 15px; background: #e0f2fe; border-radius: 4px; border: 1px solid #bae6fd; display: none; }
        .status-ok { color: green; font-weight: bold; }
        .status-err { color: red; font-weight: bold; }
        
        /* Hidden file input for restore */
        #fileInput { display: none; }
    </style>
</head>
<body>

    <div style="display: flex; justify-content: space-between; align-items: center;">
        <h1>üìö Scientific Paper Tracker</h1>
        <button class="secondary" onclick="toggleApiSettings()">‚öôÔ∏è AI Settings</button>
    </div>
    
    <div id="api-section">
        <h3>AI Configuration</h3>
        <label>1. API Key (Stored in browser)</label>
        <input type="password" id="apiKey" placeholder="Paste 'AIza...' key here" onchange="saveSettings()">
        
        <label>2. Select Model</label>
        <div style="display:flex; gap:10px;">
            <select id="modelSelect" onchange="saveSettings()">
                <option value="gemini-1.5-flash">Default (gemini-1.5-flash)</option>
            </select>
            <button class="secondary" onclick="fetchModels()">üîÑ Refresh Models</button>
        </div>
        <p id="connectionStatus" style="font-size: 0.9em; margin-top: 10px;"></p>
    </div>

    <div class="container">
        <div class="sidebar">
            <h3>Library</h3>
            <div id="tree-root" class="tree-container"></div>
            
            <div class="backup-section">
                <small style="color:#666; display:block; margin-bottom:5px;">Data Backup</small>
                <button class="secondary" style="width:100%; margin-bottom:5px;" onclick="downloadJson()">‚¨áÔ∏è Save Backup (JSON)</button>
                <button class="secondary" style="width:100%;" onclick="triggerRestore()">‚¨ÜÔ∏è Load Backup (JSON)</button>
                <input type="file" id="fileInput" accept=".json" onchange="loadJson(this)">
            </div>
        </div>

        <div class="main">
            <h3>Add New Paper</h3>
            <div class="btn-group">
                <input type="text" id="inputUrl" placeholder="Paste Paper Abstract text here...">
                <button onclick="autoFillWithAI()">‚ú® Magic Fill</button>
            </div>

            <label>Title</label>
            <input type="text" id="title">
            
            <label>Hierarchy (Path)</label>
            <input type="text" id="path" placeholder="e.g. diffusion/post-training">
            
            <label>One-Sentence Summary</label>
            <textarea id="summary" rows="2"></textarea>

            <label>BibTeX</label>
            <textarea id="bibtex" rows="5" style="font-family: monospace;"></textarea>

            <div class="btn-group">
                <button onclick="savePaper()">üíæ Save Paper</button>
                <button class="secondary" onclick="clearForm()">Clear</button>
                <button class="danger" onclick="deleteCurrentPaper()">üóëÔ∏è Delete</button>
                <button class="secondary" onclick="exportBib()">‚¨áÔ∏è Export .bib</button>
            </div>
        </div>
    </div>

    <script>
        // --- DATA LAYER ---
        let papers = JSON.parse(localStorage.getItem('myPapers')) || [];
        
        // --- API SETTINGS LAYER ---
        function getApiKey() { return localStorage.getItem('geminiKey') || ''; }
        function getModel() { return localStorage.getItem('geminiModel') || 'gemini-1.5-flash'; }

        // Load saved settings
        document.addEventListener('DOMContentLoaded', () => {
            const key = getApiKey();
            if(key) document.getElementById('apiKey').value = key;
            
            const savedModel = getModel();
            const select = document.getElementById('modelSelect');
            if(savedModel && select.options.length === 1) {
                const opt = document.createElement('option');
                opt.value = savedModel;
                opt.text = `Saved: ${savedModel}`;
                opt.selected = true;
                select.add(opt);
            }
            renderTree();
        });

        function saveSettings() {
            localStorage.setItem('geminiKey', document.getElementById('apiKey').value);
            localStorage.setItem('geminiModel', document.getElementById('modelSelect').value);
        }

        function toggleApiSettings() {
            const el = document.getElementById('api-section');
            el.style.display = el.style.display === 'none' ? 'block' : 'none';
        }

        function logStatus(msg, type='neutral') {
            const statusEl = document.getElementById('connectionStatus');
            const color = type === 'error' ? 'red' : (type === 'success' ? 'green' : '#666');
            statusEl.innerHTML = `<span style="color:${color}; font-weight:bold">${msg}</span>`;
            console.log(`[App Log] ${msg}`);
        }

        // --- BACKUP & RESTORE FEATURES ---
        function downloadJson() {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(papers, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "my_papers_backup.json");
            document.body.appendChild(downloadAnchorNode); // required for firefox
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        function triggerRestore() {
            document.getElementById('fileInput').click();
        }

        function loadJson(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const loadedPapers = JSON.parse(e.target.result);
                    if (Array.isArray(loadedPapers)) {
                        if(confirm(`Found ${loadedPapers.length} papers in backup. Replace current library?`)) {
                            papers = loadedPapers;
                            localStorage.setItem('myPapers', JSON.stringify(papers));
                            renderTree();
                            alert("Library restored successfully!");
                        }
                    } else {
                        alert("Invalid JSON format.");
                    }
                } catch (err) {
                    alert("Error reading file: " + err.message);
                }
                // Reset input so same file can be selected again
                input.value = ''; 
            };
            reader.readAsText(file);
        }

        // --- MODEL FETCHER ---
        async function fetchModels() {
            const key = document.getElementById('apiKey').value;
            if(!key) return alert("Please enter an API Key first.");
            
            logStatus("Connecting to Google...", "neutral");

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${key}`);
                const data = await response.json();

                if(data.error) throw new Error(data.error.message);
                
                const select = document.getElementById('modelSelect');
                select.innerHTML = '';
                
                const validModels = data.models.filter(m => 
                    m.supportedGenerationMethods && m.supportedGenerationMethods.includes("generateContent")
                );

                validModels.forEach(m => {
                    const cleanName = m.name.replace('models/', '');
                    const option = document.createElement('option');
                    option.value = cleanName;
                    option.text = `${m.displayName} (${cleanName})`;
                    if(cleanName.includes('1.5-flash')) option.selected = true;
                    select.appendChild(option);
                });

                logStatus(`‚úÖ Success! Found ${validModels.length} models.`, "success");
                saveSettings(); 

            } catch (e) {
                logStatus(`‚ùå Fetch Error: ${e.message}`, "error");
            }
        }

        // --- AI LOGIC ---
        async function autoFillWithAI() {
            const apiKey = getApiKey();
            const model = getModel();
            const input = document.getElementById('inputUrl').value;

            if (!apiKey) {
                toggleApiSettings();
                return alert("Please configure your API Key first.");
            }
            if (!input) return alert("Please enter the Abstract text.");

            const button = document.querySelector('button[onclick="autoFillWithAI()"]');
            const originalText = button.textContent;
            button.textContent = "‚è≥ Generating...";
            button.disabled = true;
            logStatus(`Sending request to ${model}...`, "neutral");

            const prompt = `
            You are a helpful Research Assistant and Citation Manager.
            I have this input text (Abstract or URL): 
            "${input}"

            Please perform these 4 tasks:
            1. Extract or infer the Title.
            2. Classify it into a file path (e.g. "machine_learning/transformers/attention").
            3. Write a one-sentence summary.
            4. GENERATE A VALID BIBTEX CITATION. 
               - If authors/year are missing in the text, infer them or use "Unknown" and the current year.
               - Do not leave the BibTeX field empty. 
               - Format it strictly for LaTeX use (e.g. @article{...}).

            Return ONLY raw JSON (no markdown formatting) with these exact keys:
            {
              "title": "String",
              "path": "String",
              "summary": "String",
              "bibtex": "String"
            }
            `;

            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000);

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId); 
                logStatus("Response received. Parsing...", "neutral");

                const data = await response.json();
                
                if (data.error) throw new Error(data.error.message);
                if (!data.candidates || !data.candidates[0].content) throw new Error("Safety Block or Empty Response.");

                let text = data.candidates[0].content.parts[0].text;
                text = text.replace(/```json/g, '').replace(/```/g, '').trim(); 
                
                const result = JSON.parse(text);
                
                document.getElementById('title').value = result.title || "";
                document.getElementById('path').value = (result.path || "").toLowerCase().replace(/ /g, '_');
                document.getElementById('summary').value = result.summary || "";
                
                if (result.bibtex && result.bibtex.length > 10) {
                    document.getElementById('bibtex').value = result.bibtex;
                } else {
                    document.getElementById('bibtex').value = "@misc{unknown,\n  title={" + (result.title || "Unknown") + "},\n  author={Unknown},\n  year={2024}\n}";
                }
                
                logStatus("‚úÖ Done!", "success");
                
            } catch (e) {
                if (e.name === 'AbortError') {
                    logStatus("‚ùå Timeout: Network blocked.", "error");
                    alert("Timeout! Your network blocked the request.");
                } else {
                    logStatus(`‚ùå Error: ${e.message}`, "error");
                    alert(`Error: ${e.message}`);
                }
            } finally {
                button.textContent = originalText;
                button.disabled = false;
            }
        }

        // --- APP LOGIC ---
        function savePaper() {
            const title = document.getElementById('title').value;
            if (!title) return alert("Title is required!");

            const newPaper = {
                id: Date.now(),
                title: title,
                path: document.getElementById('path').value || 'Uncategorized',
                summary: document.getElementById('summary').value,
                bibtex: document.getElementById('bibtex').value,
                url: document.getElementById('inputUrl').value,
            };

            const existingIndex = papers.findIndex(p => p.title === title);
            if (existingIndex > -1) papers.splice(existingIndex, 1);
            papers.push(newPaper);
            localStorage.setItem('myPapers', JSON.stringify(papers));
            renderTree();
            clearForm();
        }

        function loadPaper(id) {
            const paper = papers.find(p => p.id === id);
            if (!paper) return;
            document.getElementById('title').value = paper.title;
            document.getElementById('path').value = paper.path;
            document.getElementById('summary').value = paper.summary;
            document.getElementById('bibtex').value = paper.bibtex;
            document.getElementById('inputUrl').value = paper.url;
        }

        function deleteCurrentPaper() {
            const title = document.getElementById('title').value;
            if (!title) return;
            
            const existingIndex = papers.findIndex(p => p.title === title);
            if (existingIndex > -1) {
                if(confirm("Are you sure you want to delete '" + title + "'?")) {
                    papers.splice(existingIndex, 1);
                    localStorage.setItem('myPapers', JSON.stringify(papers));
                    renderTree();
                    clearForm();
                }
            }
        }

        function clearForm() {
            document.getElementById('title').value = '';
            document.getElementById('path').value = '';
            document.getElementById('summary').value = '';
            document.getElementById('bibtex').value = '';
            document.getElementById('inputUrl').value = '';
        }
        
        function exportBib() {
            const bibContent = papers.map(p => p.bibtex).join('\n\n');
            const blob = new Blob([bibContent], { type: 'text/plain' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'library.bib';
            a.click();
        }

        function renderTree() {
            const root = document.getElementById('tree-root');
            root.innerHTML = '';
            const tree = {};
            papers.forEach(p => {
                const parts = p.path.split('/').map(s => s.trim()).filter(s => s);
                let current = tree;
                parts.forEach((part, i) => {
                    if (!current[part]) current[part] = { _files: [], _folders: {} };
                    if (i === parts.length - 1) current[part]._files.push(p);
                    current = current[part]._folders;
                });
            });

            function createNode(name, data, parentElement) {
                const container = document.createElement('div');
                container.className = 'tree-item';
                if (name) {
                    const title = document.createElement('div');
                    title.className = 'folder';
                    title.textContent = name;
                    container.appendChild(title);
                }
                if (data._files) {
                    data._files.forEach(f => {
                        const fileEl = document.createElement('span');
                        fileEl.className = 'file';
                        fileEl.textContent = 'üìÑ ' + f.title;
                        fileEl.onclick = () => loadPaper(f.id);
                        container.appendChild(fileEl);
                    });
                }
                if (data._folders) {
                    Object.keys(data._folders).forEach(key => createNode(key, { _files: [], _folders: data._folders[key]._folders, ...data._folders[key] }, container));
                }
                parentElement.appendChild(container);
            }
            Object.keys(tree).forEach(k => createNode(k, tree[k], root));
        }
    </script>
</body>
</html>
