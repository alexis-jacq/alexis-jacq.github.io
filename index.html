<script>
        // --- DATA LAYER ---
        let papers = JSON.parse(localStorage.getItem('myPapers')) || [];
        
        // --- API SETTINGS LAYER ---
        function getApiKey() { return localStorage.getItem('geminiKey') || ''; }
        function getModel() { return localStorage.getItem('geminiModel') || 'gemini-1.5-flash'; }

        // Load saved settings
        document.addEventListener('DOMContentLoaded', () => {
            const key = getApiKey();
            if(key) document.getElementById('apiKey').value = key;
            
            // Restore model if saved
            const savedModel = getModel();
            const select = document.getElementById('modelSelect');
            if(savedModel && select.options.length === 1) {
                const opt = document.createElement('option');
                opt.value = savedModel;
                opt.text = `Saved: ${savedModel}`;
                opt.selected = true;
                select.add(opt);
            }
            renderTree();
        });

        function saveSettings() {
            localStorage.setItem('geminiKey', document.getElementById('apiKey').value);
            localStorage.setItem('geminiModel', document.getElementById('modelSelect').value);
        }

        function toggleApiSettings() {
            const el = document.getElementById('api-section');
            el.style.display = el.style.display === 'none' ? 'block' : 'none';
        }

        // --- LOGGING HELPER ---
        function logStatus(msg, type='neutral') {
            const statusEl = document.getElementById('connectionStatus');
            const color = type === 'error' ? 'red' : (type === 'success' ? 'green' : '#666');
            statusEl.innerHTML = `<span style="color:${color}; font-weight:bold">${msg}</span>`;
            console.log(`[App Log] ${msg}`);
        }

        // --- MODEL FETCHER ---
        async function fetchModels() {
            const key = document.getElementById('apiKey').value;
            if(!key) return alert("Please enter an API Key first.");
            
            logStatus("Connecting to Google to fetch models...", "neutral");

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${key}`);
                const data = await response.json();

                if(data.error) throw new Error(data.error.message);
                
                const select = document.getElementById('modelSelect');
                select.innerHTML = '';
                
                // Filter for content generation models
                const validModels = data.models.filter(m => 
                    m.supportedGenerationMethods && m.supportedGenerationMethods.includes("generateContent")
                );

                validModels.forEach(m => {
                    const cleanName = m.name.replace('models/', '');
                    const option = document.createElement('option');
                    option.value = cleanName;
                    option.text = `${m.displayName} (${cleanName})`;
                    if(cleanName.includes('1.5-flash')) option.selected = true;
                    select.appendChild(option);
                });

                logStatus(`âœ… Success! Found ${validModels.length} models.`, "success");
                saveSettings(); 

            } catch (e) {
                logStatus(`âŒ Fetch Error: ${e.message}`, "error");
            }
        }

        // --- AI LOGIC (With Timeout & Debugging) ---
        async function autoFillWithAI() {
            const apiKey = getApiKey();
            const model = getModel();
            const input = document.getElementById('inputUrl').value;

            if (!apiKey) {
                toggleApiSettings();
                return alert("Please configure your API Key first.");
            }
            if (!input) return alert("Please enter the Abstract text.");

            // UI Updates
            const button = document.querySelector('button[onclick="autoFillWithAI()"]');
            const originalText = button.textContent;
            button.textContent = "â³ Sending...";
            button.disabled = true;
            logStatus(`Sending request to ${model}...`, "neutral");

            // --- IMPORTANT: THE PROMPT ---
            // Note: Basic Gemini API cannot visit URLs. We ask it to guess from the URL string or process text.
            const prompt = `
            I have this input: "${input}".
            If it is a URL, try to infer the paper details from the URL slug. 
            If it is text, summarize it.
            
            Return ONLY valid JSON: {"title": "...", "path": "field/subfield", "summary": "...", "bibtex": "..."}
            `;

            // Setup Timeout (15 seconds)
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 15000);

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] }),
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId); // Clear timeout if successful
                logStatus("Response received. Parsing...", "neutral");

                const data = await response.json();
                
                if (data.error) throw new Error(data.error.message);
                if (!data.candidates || !data.candidates[0].content) throw new Error("Safety Block or Empty Response.");

                let text = data.candidates[0].content.parts[0].text;
                text = text.replace(/```json/g, '').replace(/```/g, ''); 
                
                const result = JSON.parse(text);
                
                document.getElementById('title').value = result.title || "";
                document.getElementById('path').value = (result.path || "").toLowerCase().replace(/ /g, '_');
                document.getElementById('summary').value = result.summary || "";
                document.getElementById('bibtex').value = result.bibtex || "";
                
                logStatus("âœ… Done!", "success");
                
            } catch (e) {
                if (e.name === 'AbortError') {
                    logStatus("âŒ Timeout: Network took too long. (Firewall blocking POST?)", "error");
                    alert("Timeout! \n\nYour network seems to be blocking the 'Send' request to Google AI. \n\nTry using a mobile hotspot or personal WiFi.");
                } else {
                    logStatus(`âŒ Error: ${e.message}`, "error");
                    alert(`Error: ${e.message}`);
                }
            } finally {
                button.textContent = originalText;
                button.disabled = false;
            }
        }

        // --- APP LOGIC ---
        function savePaper() {
            const title = document.getElementById('title').value;
            if (!title) return alert("Title is required!");

            const newPaper = {
                id: Date.now(),
                title: title,
                path: document.getElementById('path').value || 'Uncategorized',
                summary: document.getElementById('summary').value,
                bibtex: document.getElementById('bibtex').value,
                url: document.getElementById('inputUrl').value,
            };

            const existingIndex = papers.findIndex(p => p.title === title);
            if (existingIndex > -1) papers.splice(existingIndex, 1);
            papers.push(newPaper);
            localStorage.setItem('myPapers', JSON.stringify(papers));
            renderTree();
            clearForm();
        }

        function loadPaper(id) {
            const paper = papers.find(p => p.id === id);
            if (!paper) return;
            document.getElementById('title').value = paper.title;
            document.getElementById('path').value = paper.path;
            document.getElementById('summary').value = paper.summary;
            document.getElementById('bibtex').value = paper.bibtex;
            document.getElementById('inputUrl').value = paper.url;
        }

        function clearForm() {
            document.getElementById('title').value = '';
            document.getElementById('path').value = '';
            document.getElementById('summary').value = '';
            document.getElementById('bibtex').value = '';
            document.getElementById('inputUrl').value = '';
        }
        
        function exportBib() {
            const bibContent = papers.map(p => p.bibtex).join('\n\n');
            const blob = new Blob([bibContent], { type: 'text/plain' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'library.bib';
            a.click();
        }

        function renderTree() {
            const root = document.getElementById('tree-root');
            root.innerHTML = '';
            const tree = {};
            papers.forEach(p => {
                const parts = p.path.split('/').map(s => s.trim()).filter(s => s);
                let current = tree;
                parts.forEach((part, i) => {
                    if (!current[part]) current[part] = { _files: [], _folders: {} };
                    if (i === parts.length - 1) current[part]._files.push(p);
                    current = current[part]._folders;
                });
            });

            function createNode(name, data, parentElement) {
                const container = document.createElement('div');
                container.className = 'tree-item';
                if (name) {
                    const title = document.createElement('div');
                    title.className = 'folder';
                    title.textContent = name;
                    container.appendChild(title);
                }
                if (data._files) {
                    data._files.forEach(f => {
                        const fileEl = document.createElement('span');
                        fileEl.className = 'file';
                        fileEl.textContent = 'ðŸ“„ ' + f.title;
                        fileEl.onclick = () => loadPaper(f.id);
                        container.appendChild(fileEl);
                    });
                }
                if (data._folders) {
                    Object.keys(data._folders).forEach(key => createNode(key, { _files: [], _folders: data._folders[key]._folders, ...data._folders[key] }, container));
                }
                parentElement.appendChild(container);
            }
            Object.keys(tree).forEach(k => createNode(k, tree[k], root));
        }
    </script>
