<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Paper Tracker</title>
    <style>
        :root { --primary: #2563eb; --success: #16a34a; --bg: #f8fafc; --text: #1e293b; --danger: #ef4444; }
        body { font-family: -apple-system, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; background: var(--bg); color: var(--text); }
        .container { display: grid; grid-template-columns: 300px 1fr; gap: 20px; }
        
        /* Sidebar */
        .sidebar { background: white; padding: 15px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); height: 85vh; display: flex; flex-direction: column; }
        .tree-container { flex-grow: 1; overflow-y: auto; margin-bottom: 15px; }
        .backup-section { border-top: 1px solid #eee; padding-top: 15px; }
        
        /* Tree UI */
        .tree-item { margin-top: 5px; }
        .folder { font-weight: bold; cursor: pointer; color: #475569; font-size: 0.95em; user-select: none; display: flex; align-items: center; gap: 5px;}
        .folder:hover { color: var(--primary); }
        .folder::before { content: "‚ñ∂"; font-size: 0.7em; display: inline-block; width: 15px; transition: transform 0.2s; }
        .folder.open::before { content: "‚ñº"; transform: rotate(0deg); }
        .children-container { display: none; margin-left: 9px; padding-left: 15px; border-left: 1px solid #e2e8f0; }
        .children-container.expanded { display: block; }
        .file { cursor: pointer; font-size: 0.9em; margin-top: 6px; display: block; text-decoration: none; padding: 2px 0; margin-left: 5px;}
        .file:hover { text-decoration: underline; }
        .status-unread { color: var(--primary); }
        .status-unread::before { content: "üìñ "; }
        .status-read { color: var(--success); opacity: 0.8; }
        .status-read::before { content: "‚úÖ "; }

        /* Main Content */
        .main { background: white; padding: 25px; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); position: relative; }
        input[type="text"], textarea, select { width: 100%; margin-bottom: 10px; padding: 8px; border: 1px solid #ccc; border-radius: 4px; box-sizing: border-box;}
        
        /* Search Box Styles */
        .search-box { display: flex; gap: 10px; margin-bottom: 10px; }
        .search-results { max-height: 200px; overflow-y: auto; border: 1px solid #eee; display: none; margin-bottom: 15px; border-radius: 4px; }
        .result-item { padding: 10px; border-bottom: 1px solid #eee; cursor: pointer; transition: background 0.1s; }
        .result-item:hover { background: #f0f9ff; }
        .result-title { font-weight: bold; font-size: 0.95em; }
        .result-meta { font-size: 0.8em; color: #666; }

        .link-group { display: flex; gap: 10px; align-items: flex-start; }
        .link-group input { flex-grow: 1; }
        .link-btn { white-space: nowrap; padding: 8px 15px; height: 35px; background: #fff; border: 1px solid #ccc; color: #333; }
        
        .checkbox-wrapper { display: flex; align-items: center; gap: 10px; margin-bottom: 20px; background: #f0f9ff; padding: 10px; border-radius: 4px; border: 1px solid #bae6fd; }
        input[type="checkbox"] { transform: scale(1.5); cursor: pointer; }
        
        .btn-group { display: flex; gap: 10px; margin-bottom: 20px; }
        button { background: var(--primary); color: white; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; }
        button.secondary { background: #64748b; }
        button.danger { background: var(--danger); }
        button:hover { opacity: 0.9; }
        
        #api-section { margin-bottom: 20px; padding: 15px; background: #e0f2fe; border-radius: 4px; border: 1px solid #bae6fd; display: none; }
        #fileInput { display: none; }
    </style>
</head>
<body>

    <div style="display: flex; justify-content: space-between; align-items: center;">
        <h1>üìö Scientific Paper Tracker</h1>
        <button class="secondary" onclick="toggleApiSettings()">‚öôÔ∏è AI Settings</button>
    </div>
    
    <div id="api-section">
        <h3>AI Configuration</h3>
        <label>1. API Key (Stored in browser)</label>
        <input type="password" id="apiKey" placeholder="Paste 'AIza...' key here" onchange="saveSettings()">
        <label>2. Select Model</label>
        <div style="display:flex; gap:10px;">
            <select id="modelSelect" onchange="saveSettings()">
                <option value="gemini-1.5-flash">Default (gemini-1.5-flash)</option>
            </select>
            <button class="secondary" onclick="fetchModels()">üîÑ Refresh Models</button>
        </div>
        <p id="connectionStatus" style="font-size: 0.9em; margin-top: 10px;"></p>
    </div>

    <div class="container">
        <div class="sidebar">
            <h3>Library</h3>
            <div id="tree-root" class="tree-container"></div>
            <div class="backup-section">
                <small style="color:#666; display:block; margin-bottom:5px;">Data Backup</small>
                <button class="secondary" style="width:100%; margin-bottom:5px;" onclick="downloadJson()">‚¨áÔ∏è Save Backup (JSON)</button>
                <button class="secondary" style="width:100%;" onclick="triggerRestore()">‚¨ÜÔ∏è Load Backup (JSON)</button>
                <input type="file" id="fileInput" accept=".json" onchange="loadJson(this)">
            </div>
        </div>

        <div class="main">
            <h3>Add New Paper</h3>
            
            <label>Search Paper (Semantic Scholar)</label>
            <div class="search-box">
                <input type="text" id="searchInput" placeholder="Type paper title..." onkeydown="if(event.key === 'Enter') searchPapers()">
                <button onclick="searchPapers()">üîç Search</button>
            </div>
            <div id="searchResults" class="search-results"></div>

            <hr style="border: 0; border-top: 1px solid #eee; margin: 20px 0;">

            <label>Title</label>
            <input type="text" id="title">
            
            <label>Paper Link / URL</label>
            <div class="link-group">
                <input type="text" id="paperLink" placeholder="https://arxiv.org/...">
                <button class="link-btn" onclick="openLink()">üîó Open</button>
            </div>
            
            <label>Hierarchy (Path)</label>
            <div style="display: flex; gap: 10px;">
                <input type="text" id="path" placeholder="e.g. diffusion/post-training">
                <button class="secondary" style="width: 120px;" onclick="runAiCategorization()">‚ú® AI Path</button>
            </div>
            
            <div class="checkbox-wrapper">
                <input type="checkbox" id="readStatus">
                <label for="readStatus" style="font-weight:bold; color:#1e293b;">Mark as Read / Finished</label>
            </div>
            
            <label>Abstract (Auto-filled)</label>
            <textarea id="abstractText" rows="4" placeholder="Abstract will appear here..."></textarea>
            
            <label>One-Sentence Summary</label>
            <div style="display: flex; gap: 10px; align-items: flex-start;">
                <textarea id="summary" rows="2"></textarea>
                <button class="secondary" style="height: 60px;" onclick="runAiSummary()">‚ú® AI Summarize</button>
            </div>

            <label>BibTeX</label>
            <textarea id="bibtex" rows="5" style="font-family: monospace;"></textarea>

            <div class="btn-group">
                <button onclick="savePaper()">üíæ Save Paper</button>
                <button class="secondary" onclick="clearForm()">Clear</button>
                <button class="danger" onclick="deleteCurrentPaper()">üóëÔ∏è Delete</button>
                <button class="secondary" onclick="exportBib()">‚¨áÔ∏è Export .bib</button>
            </div>
        </div>
    </div>

    <script>
        // --- DATA LAYER ---
        let papers = JSON.parse(localStorage.getItem('myPapers')) || [];
        let expandedPaths = new Set();
        
        // --- API & SETTINGS ---
        function getApiKey() { return localStorage.getItem('geminiKey') || ''; }
        function getModel() { return localStorage.getItem('geminiModel') || 'gemini-1.5-flash'; }

        document.addEventListener('DOMContentLoaded', () => {
            const key = getApiKey();
            if(key) document.getElementById('apiKey').value = key;
            const savedModel = getModel();
            const select = document.getElementById('modelSelect');
            if(savedModel && select.options.length === 1) {
                const opt = document.createElement('option');
                opt.value = savedModel;
                opt.text = `Saved: ${savedModel}`;
                opt.selected = true;
                select.add(opt);
            }
            renderTree();
        });

        function saveSettings() {
            localStorage.setItem('geminiKey', document.getElementById('apiKey').value);
            localStorage.setItem('geminiModel', document.getElementById('modelSelect').value);
        }

        function toggleApiSettings() {
            const el = document.getElementById('api-section');
            el.style.display = el.style.display === 'none' ? 'block' : 'none';
        }

        function logStatus(msg, type='neutral') {
            const statusEl = document.getElementById('connectionStatus');
            const color = type === 'error' ? 'red' : (type === 'success' ? 'green' : '#666');
            statusEl.innerHTML = `<span style="color:${color}; font-weight:bold">${msg}</span>`;
        }

        // --- SEMANTIC SCHOLAR SEARCH ---
        async function searchPapers() {
            const query = document.getElementById('searchInput').value;
            if(!query) return alert("Please enter a title.");
            
            const resultsDiv = document.getElementById('searchResults');
            resultsDiv.style.display = 'block';
            resultsDiv.innerHTML = '<div style="padding:10px;">Searching Semantic Scholar...</div>';

            try {
                // Fetch basic details
                const response = await fetch(`https://api.semanticscholar.org/graph/v1/paper/search?query=${encodeURIComponent(query)}&limit=5&fields=title,authors,year,abstract,url,venue,isOpenAccess,openAccessPdf`);
                const data = await response.json();
                
                if(!data.data || data.data.length === 0) {
                    resultsDiv.innerHTML = '<div style="padding:10px;">No papers found.</div>';
                    return;
                }

                resultsDiv.innerHTML = '';
                data.data.forEach(paper => {
                    const el = document.createElement('div');
                    el.className = 'result-item';
                    const authors = paper.authors ? paper.authors.map(a => a.name).slice(0, 3).join(', ') : 'Unknown';
                    el.innerHTML = `
                        <div class="result-title">${paper.title}</div>
                        <div class="result-meta">${paper.year || 'No Year'} ‚Ä¢ ${authors}</div>
                    `;
                    el.onclick = () => selectPaper(paper);
                    resultsDiv.appendChild(el);
                });

            } catch (e) {
                console.error(e);
                resultsDiv.innerHTML = '<div style="padding:10px; color:red;">Error fetching papers.</div>';
            }
        }

        function selectPaper(paper) {
            // 1. Fill basic fields
            document.getElementById('title').value = paper.title;
            document.getElementById('abstractText').value = paper.abstract || "No abstract available.";
            
            // 2. Determine best link
            let link = paper.url;
            if(paper.openAccessPdf && paper.openAccessPdf.url) link = paper.openAccessPdf.url;
            document.getElementById('paperLink').value = link || "";

            // 3. Generate BibTeX manually (Semantic Scholar API sends JSON)
            const firstAuthor = paper.authors && paper.authors.length > 0 ? paper.authors[0].name.split(' ').pop() : 'unknown';
            const year = paper.year || '2024';
            const citationKey = `${firstAuthor.toLowerCase()}${year}${paper.title.split(' ')[0].toLowerCase()}`;
            
            let authorList = paper.authors ? paper.authors.map(a => a.name).join(' and ') : 'Unknown';
            
            const bib = `@article{${citationKey},
  title={${paper.title}},
  author={${authorList}},
  journal={${paper.venue || 'ArXiv'}},
  year={${year}},
  url={${link || ''}}
}`;
            document.getElementById('bibtex').value = bib;

            // 4. Close Search
            document.getElementById('searchResults').style.display = 'none';

            // 5. Trigger AI for Summary and Path
            if(paper.abstract) {
                runAiCategorization(true); // pass true to indicate it's auto-triggered
            }
        }

        // --- AI LOGIC (Split into Summary vs Path) ---
        async function runAiCategorization(isAuto = false) {
            const abstract = document.getElementById('abstractText').value;
            const title = document.getElementById('title').value;
            if(!abstract && !title) return alert("Fill Title/Abstract first.");

            const button = document.querySelector('button[onclick="runAiCategorization()"]');
            if(!isAuto) button.textContent = "‚è≥...";

            const prompt = `
            Based on Title: "${title}" and Abstract: "${abstract.substring(0, 500)}...", 
            suggest a folder path (e.g. machine_learning/transformers). 
            Return JSON: {"path": "string", "summary": "string"}. 
            Also generate a 1-sentence summary.
            `;
            
            await callGemini(prompt, (result) => {
                document.getElementById('path').value = (result.path || "uncategorized").toLowerCase().replace(/ /g, '_');
                document.getElementById('summary').value = result.summary || "";
                if(!isAuto) button.textContent = "‚ú® AI Path";
            });
        }

        async function runAiSummary() {
            const abstract = document.getElementById('abstractText').value;
            if(!abstract) return alert("No abstract to summarize.");
            
            const button = document.querySelector('button[onclick="runAiSummary()"]');
            button.textContent = "‚è≥...";

            const prompt = `Summarize this in one insightful sentence: "${abstract.substring(0, 1000)}..." Return JSON: {"summary": "string"}`;
            
            await callGemini(prompt, (result) => {
                document.getElementById('summary').value = result.summary;
                button.textContent = "‚ú® AI Summarize";
            });
        }

        async function callGemini(promptText, callback) {
            const apiKey = getApiKey();
            const model = getModel();
            if(!apiKey) return alert("Please configure API Key.");

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: promptText }] }] })
                });
                const data = await response.json();
                if(data.error) throw new Error(data.error.message);
                
                let text = data.candidates[0].content.parts[0].text.replace(/```json/g, '').replace(/```/g, '').trim();
                callback(JSON.parse(text));
            } catch (e) {
                console.error(e);
                alert("AI Error: " + e.message);
            }
        }

        // --- APP LOGIC ---
        function openLink() {
            const url = document.getElementById('paperLink').value;
            if(url) window.open(url, '_blank');
            else alert("No link entered.");
        }

        function savePaper() {
            const title = document.getElementById('title').value;
            if (!title) return alert("Title is required!");

            const newPaper = {
                id: Date.now(),
                title: title,
                path: document.getElementById('path').value || 'Uncategorized',
                abstract: document.getElementById('abstractText').value,
                summary: document.getElementById('summary').value,
                bibtex: document.getElementById('bibtex').value,
                link: document.getElementById('paperLink').value,
                read: document.getElementById('readStatus').checked
            };

            const existingIndex = papers.findIndex(p => p.title === title);
            if (existingIndex > -1) {
                newPaper.id = papers[existingIndex].id;
                papers.splice(existingIndex, 1);
            }
            
            papers.push(newPaper);
            localStorage.setItem('myPapers', JSON.stringify(papers));
            renderTree();
            clearForm();
        }

        function loadPaper(id) {
            const paper = papers.find(p => p.id === id);
            if (!paper) return;
            document.getElementById('title').value = paper.title;
            document.getElementById('path').value = paper.path;
            document.getElementById('abstractText').value = paper.abstract || "";
            document.getElementById('summary').value = paper.summary;
            document.getElementById('bibtex').value = paper.bibtex;
            document.getElementById('paperLink').value = paper.link || "";
            document.getElementById('readStatus').checked = paper.read || false;
        }

        function deleteCurrentPaper() {
            const title = document.getElementById('title').value;
            if (!title) return;
            const existingIndex = papers.findIndex(p => p.title === title);
            if (existingIndex > -1 && confirm("Delete '" + title + "'?")) {
                papers.splice(existingIndex, 1);
                localStorage.setItem('myPapers', JSON.stringify(papers));
                renderTree();
                clearForm();
            }
        }

        function clearForm() {
            document.getElementById('title').value = '';
            document.getElementById('path').value = '';
            document.getElementById('abstractText').value = '';
            document.getElementById('summary').value = '';
            document.getElementById('bibtex').value = '';
            document.getElementById('paperLink').value = '';
            document.getElementById('searchInput').value = '';
            document.getElementById('searchResults').style.display = 'none';
            document.getElementById('readStatus').checked = false;
        }

        function exportBib() {
            const bibContent = papers.map(p => p.bibtex).join('\n\n');
            const blob = new Blob([bibContent], { type: 'text/plain' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = 'library.bib';
            a.click();
        }

        // --- BACKUP & RESTORE ---
        function downloadJson() {
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(papers, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "my_papers_backup.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }
        function triggerRestore() { document.getElementById('fileInput').click(); }
        function loadJson(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const loadedPapers = JSON.parse(e.target.result);
                    if (Array.isArray(loadedPapers)) {
                        if(confirm(`Found ${loadedPapers.length} papers. Replace library?`)) {
                            papers = loadedPapers;
                            localStorage.setItem('myPapers', JSON.stringify(papers));
                            renderTree();
                            alert("Restored!");
                        }
                    } else alert("Invalid JSON.");
                } catch (err) { alert("Error: " + err.message); }
                input.value = ''; 
            };
            reader.readAsText(file);
        }

        // --- MODEL FETCHER ---
        async function fetchModels() {
            const key = document.getElementById('apiKey').value;
            if(!key) return alert("Please enter an API Key first.");
            logStatus("Connecting...", "neutral");
            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${key}`);
                const data = await response.json();
                if(data.error) throw new Error(data.error.message);
                const select = document.getElementById('modelSelect');
                select.innerHTML = '';
                const validModels = data.models.filter(m => m.supportedGenerationMethods?.includes("generateContent"));
                validModels.forEach(m => {
                    const cleanName = m.name.replace('models/', '');
                    const option = document.createElement('option');
                    option.value = cleanName;
                    option.text = `${m.displayName} (${cleanName})`;
                    if(cleanName.includes('1.5-flash')) option.selected = true;
                    select.appendChild(option);
                });
                logStatus(`‚úÖ Found ${validModels.length} models.`, "success");
                saveSettings(); 
            } catch (e) { logStatus(`‚ùå Error: ${e.message}`, "error"); }
        }

        // --- TREE RENDER ---
        function renderTree() {
            const root = document.getElementById('tree-root');
            root.innerHTML = '';
            const tree = {};
            
            papers.forEach(p => {
                const parts = p.path.split('/').map(s => s.trim()).filter(s => s);
                let current = tree;
                parts.forEach((part, i) => {
                    if (!current[part]) current[part] = { _files: [], _folders: {} };
                    if (i === parts.length - 1) current[part]._files.push(p);
                    current = current[part]._folders;
                });
            });

            function createNode(name, data, parentElement, fullPath) {
                const itemContainer = document.createElement('div');
                itemContainer.className = 'tree-item';

                if (name) {
                    const folderDiv = document.createElement('div');
                    folderDiv.className = 'folder';
                    
                    const icon = document.createElement('span');
                    icon.textContent = 'üìÇ';
                    
                    folderDiv.appendChild(icon);
                    folderDiv.appendChild(document.createTextNode(name));

                    const isOpen = expandedPaths.has(fullPath);
                    if(isOpen) folderDiv.classList.add('open');
                    
                    folderDiv.onclick = (e) => {
                        const childrenEl = itemContainer.querySelector('.children-container');
                        if(childrenEl) {
                            if(childrenEl.classList.contains('expanded')) {
                                childrenEl.classList.remove('expanded');
                                folderDiv.classList.remove('open');
                                expandedPaths.delete(fullPath);
                            } else {
                                childrenEl.classList.add('expanded');
                                folderDiv.classList.add('open');
                                expandedPaths.add(fullPath);
                            }
                        }
                    };
                    itemContainer.appendChild(folderDiv);
                }

                const childrenContainer = document.createElement('div');
                childrenContainer.className = 'children-container';
                if(expandedPaths.has(fullPath) || !name) {
                    childrenContainer.classList.add('expanded');
                }

                if (data._files) {
                    const sortedFiles = data._files.sort((a, b) => a.title.localeCompare(b.title));
                    sortedFiles.forEach(f => {
                        const fileEl = document.createElement('span');
                        const isRead = f.read === true;
                        fileEl.className = 'file ' + (isRead ? 'status-read' : 'status-unread');
                        fileEl.textContent = f.title;
                        fileEl.onclick = () => loadPaper(f.id);
                        childrenContainer.appendChild(fileEl);
                    });
                }

                if (data._folders) {
                    const sortedKeys = Object.keys(data._folders).sort();
                    sortedKeys.forEach(key => {
                        const nextPath = fullPath ? `${fullPath}/${key}` : key;
                        createNode(key, { 
                            _files: [], 
                            _folders: data._folders[key]._folders, 
                            ...data._folders[key] 
                        }, childrenContainer, nextPath);
                    });
                }
                
                if (childrenContainer.hasChildNodes()) {
                    itemContainer.appendChild(childrenContainer);
                }
                parentElement.appendChild(itemContainer);
            }
            Object.keys(tree).sort().forEach(k => createNode(k, tree[k], root, k));
        }
    </script>
</body>
</html>
